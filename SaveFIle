#Size coimparison
type - <class 'dict'>, len - 100, size - 2620         #   {i:i for i in range(100)}
type - <class 'set'>, len - 100, size - 4212          #   {i for i in range(100)}
type - <class 'list'>, len - 100, size - 460            #   [i for i in range(100)]
type - <class 'tuple'>, len - 100, size - 428         #   tuple((i for i in range(100)))
type - <class 'generator'>, len - 100, size - 48   #   (i for i in range(100))

| Use case                        | Use this     |
|----------------------------------|--------------|
| Ordered simple items             | `list`       |
| Unique unordered items           | `set`        |
| Key → Value mapping              | `dict`       |
| Need fast lookup                 | `set` / `dict` |
| Tiny memory budget               | `list`       |

import this

#Calculator 

a = float(input())
b = float(input())
act = input()

if (act=="/" or act=="mod" or act=="div") and b==0:
    c = "Деление на 0!"
elif act=="+":    c = a + b
elif act=="-":    c = a - b
elif act=="/":    c = a / b
elif act=="*":    c = a * b
elif act=="mod":  c = a % b
elif act=="pow":  c = a ** b
elif act=="div":  c = a // b

print (c) 

#Labeling 

n = int(input()) 

if n % 10 in [1] and not ( n % 100 == 11 ) : 
  print(n, "программист")

elif n % 10 in [2, 3, 4] and not ( 12 <= n % 100 <= 14 ) :
  print(n, "программиста") 

else : 
  print(n, "программистов") 


#Lucky Ticket 

n = int(input()) 

a = n // 100000 % 10 
b = n // 10000 % 10 
c = n // 1000 % 10 
d = n // 100 % 10 
e = n // 10 % 10 
f = n % 10 

if a + b + c == d + e + f: 
    print('Счастливый')
elif a + b + c != d + e + f : 
    print('Обычный')

#Sum 

a = int(input()) 
s = a
while not a == 0 :
  a = int(input()) 
  s += a 
print(s)

#НОД 

a = int(input())
b = int(input())

d = 2  # начинаем с первого возможного делителя > 1

while d <= a and d <= b:
    if a % d == 0 and b % d == 0:
        print("Наименьший общий делитель:", d)
        break
    d += 1
else:
  print("Нет общих делителей кроме 1") 

#Таблица умножения 
a = int(input())
b = int(input())

for i in range(a, b + 1):
  print('', i, end="\n\n") 

for j in range(c, d+1): 
  print('\t', j, end='\t') 
print()

#i for range 

a, b = (int(i) for i in input().split())
s = 0
n = 0
for i in range(a, b + 1):
  if i % 3 == 0:
    s += i
    n += 1
s = s / n
print(s)

#indexing 

genome = 'ATGG'

genome[0] = 'A'
genome[-4] = 'A'

=> genome = 'ATGG'
for i in range(4):
  print(genome[i]) 

or

genome = 'ATGG'
for i in genome:
  print(i)

genome = 'ATSGD'
print(genome.count('C')) 

if 'TG' in s: 
s.upper().count('gt'.upper())

#Slicing

dna = 'ATTCGGAGCT'
dna[1:4:2] 
dna[::-1] = TCGAGGCTTA

genom = input()
n = len(genom)

#Save Memory
genom = input()
n = len(genom)

i = 0
while i < n:
    s = 1
    while i + 1 < n and genom[i] == genom[i + 1]:
        s += 1
        i += 1
    print(genom[i] + str(count))
    i += 1

print('end') 

#Lists 

students = ['Ivan', 'Masha', 'Sasha']
print(students[1:3]) 
List1 + List2 = List1, List2
List * 2 = List, List
* List elements are CHANGABLE 
* List.append['Olga'] - add 1 item to the box
* List += ['Boris'] - expand by range 
* List.insert(1, 'Olga') - add on place 

* del students[1:3]
* students.remove('Sasha') 

* if ... (not) in List
* ind = students.index('Sasha')

* ordered_students = sorted(students)
* students.sort

* min(students) 
* max(students) 

* students.reserse() - change List's state
* reversed(students) <=> students[::-1] - use as reversed 

                    ГЕНЕРАЦИЯ СПИСКОВ 

a = [0]*5 
a = [0 for i in range(5)]
a = [i*i for i in range(5)]
a = [int(i) for i in input().split()] 
* for i, fruit in enumerate(fruits):
    print(i, fruit) -- use index and value.

#Сумма
a = [int(i) for i in input().split()] 
s = 0

for i in a:
    s += i
print(s)

#Alg

a = [int(i) for i in input().split()]
n = len(a)

for i in range(n):
    if i == 0:
        print(a[1] + a[-1], end=' ')
    elif i == n - 1:
        print(a[-2] + a[0], end=' ')
    else:
        print(a[i - 1] + a[i + 1], end=' ')

#Return same values

a = [int(i) for i in input().split()]
a.sort()
n = len(a)

i = 0
while i < n - 1:
    if a[i] == a[i + 1]:
        print(a[i], end=' ')
        while i < n - 1 and a[i] == a[i + 1]:
            i += 1
    i += 1 

    ДВУМЕРНЫЕ СПИСКИ 

a = [[1,2,3],[4,5,6],[7,8,9]] - matrix 3x3
a[1][1] - stroke number, field number 
a = [[0]*n]*n
a[0][0] = 5 - changes all lists as in original stroke

Generators: 
a = [[0] * n for i in range(n)]
a = [[0 for j in range(n)] for i in range(n)]

#Count Matrix 
n = 3
count = 1
a = [[0 for j in range(n)] for i in range(n)]

for i in range(n):
    for j in range(n):
        a[i][j] = count
        count += 1

#Edit Matrix

b = [int(y) for y in input().split()]

for i in range(n):
    for j in range(m):
        if i == b[0] and j == b[1]:
            a[b[0] - 1][b[1] - 1] = -1
        else: a[i][j] = 0

for i in range(n):
    for j in range(m):
        print(a[i][j], end='\t')
    print() 

#Mine FIeld

n, m, k = (int(i) for i in input().split())
a = [[0 for i in range(m)] for j in range(n)]
for i in range(k):
    row, col = [int(i) - 1 for i in input().split()]
    a[row][col] = -1
for i in range(n):
    for j in range(m):
        if a[i][j] == 0:
            for di in range(-1, 2):
                for dj in range(-1, 2):
                    ai = i + di
                    aj = j + dj
                    if 0 <= ai < n and 0 <= aj < m and a[ai][aj] == -1:
                        a[i][j] += 1
for i in range(n):
    for j in range(m):
        if a[i][j] == -1:
            print('*', end='')
        elif a[i][j] == 0:
            print('.', end='') 
        else:
            print(a[i][j], end='')
    print()

#Run first loop with no req 

s = 0
d = 0
first_cycle = True

while d != 0 or first_cycle:
    first_cycle = False
    try:
        k = int(input())
    except EOFError:
        break
    s += k ** 2
    d += k
print(s)

#Lists setting

a = int(input())
res = []
n = 1

while len(res) < a:
    for i in range(n):
        if len(res) >= a:
            break
        res.append(n)
    n += 1

print(*res)

#Remake matrix

a = []
k = 0

while True:
    s = input()
    if s == 'end':
        break
    b = [int(i) for i in s.split()]
    a.append(b)
    k += 1

n = len(a)

for i in range(k):  # fix here — no need for k+1
    for j in a[i]:
        print(j, end=' ')
    print()

#Edit Matrix

a = []
k = 0

while True:
    s = input()
    if s == 'end':
        break
    b = [int(i) for i in s.split()]
    a.append(b)
    k += 1
n = len(a[0])

result = []

for i in range(k):
    row = []
    for j in range(n):
        up = a[i - 1][j] if i > 0 else a[k - 1][j]
        down = a[i + 1][j] if i < k - 1 else a[0][j]
        left = a[i][j - 1] if j > 0 else a[i][n - 1]
        right = a[i][j + 1] if j < n - 1 else a[i][0]
        row.append(up + down + left + right)
    result.append(row)
    
for row in result:  # fix here — no need for k+1
    for j in row:
        print(j, end=' ')
    print()

#Add Sublist 
b.append(list(range(k, n + 1)))

#NxN Matrix

n = int(input())
a = []
k = 1  # first number

for i in range(n):
    b = []
    for j in range(n):
        b.append(k)
        k += 1
    a.append(b)

for row in a:
    for j in row:
        print(j, end=' ')
    print()

#Build 0xN Matrix

n = int(input())
a = []

a = [[0 for j in range(n)] for i in range(n)]

for i in range(n):
    for j in range(n):
        print(a[i][j], end=' ')
    print()

#Matrix Spiral

n = int(input())
a = [[0 for _ in range(n)] for _ in range(n)]

top = 0
bottom = n - 1
left = 0
right = n - 1
k = 1

while k <= n * n:
    # → Fill top row
    for j in range(left, right + 1):
        a[top][j] = k
        k += 1
    top += 1

    # ↓ Fill right column
    for i in range(top, bottom + 1):
        a[i][right] = k
        k += 1
    right -= 1

    # ← Fill bottom row
    for j in range(right, left - 1, -1):
        a[bottom][j] = k
        k += 1
    bottom -= 1

    # ↑ Fill left column
    for i in range(bottom, top - 1, -1):
        a[i][left] = k
        k += 1
    left += 1

# Print the matrix
for row in a:
    for val in row:
        print(val, end=' ')
    print()

                                                ФУНКЦИИ

* def - определить функцию
* return - закончить и вернуть значение
• what starts in function stays in function
•  Списки, словари, множества - это изменяемые объекты
• Числа, строки, кортежи - это неизменяемые объекты

#example
a = 0

def init_values(a):
    a = 100
    return(a)
print(init_values(a))

#min

a = [0, 1, 3, 4, -1, -100]

def my_min(*args):
    m = args[0]
    for x in args:
        if m > x:
            m = x
    return m
print(my_min(*a))

#range in list

def my_range(start, stop, step=1):
    res = []
    if step > 0:
        x = start
        while x < stop:
            res += [x]
            x += step
    elif step < 0:
        x = start
        while x > stop:
            res += [x]
            x += step
    return(res)
print(my_range(stop = 20, start = 5))

#Modify list + safe cycle

def modify_list(l):
    for i in range(len(l) - 1, -1, -1):
        if l[i] % 2 != 0:
            del l[i]
        else:
            l[i] //= 2

a = [1, 2, 3, 4, 5, 6]
modify_list(a)
print(a)

#In-place assignment

def modify_list(l):
    l[:] = [i//2 for i in l if i % 2 == 0]1] 

                        МНОЖЕСТВА 

* s = set() - empty set
* basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
- print(basket) - {'orange', 'banana', 'pear', 'apple'}
* 'orange' in basket
* s.add(element)
* s.remove(element) - error if none
* s.discard(element) - no error if none
* s.clear() - clear set

#Example
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
for x in basket:
  print(x) - outputs banana, apple, orange, pear 

                        СЛОВАРИ 

* d = dict() or d = {} - empty dictionary 
* d = {'a': 239,10:100}, a - key, 239 - value
* key in dictionary
* dictionary[key] = value
* dictionary[key] - might give error
* dictionary.get[key] - stable
* del dictionary[key] 
• Dictionaries or changable
• Keys are unchangable 

* Перебрать словарь
d = {'C':14, 'A':12}
for key in d:
    print(key, end=' ') -- C A 
for key in d.keys():
    print(key, end=' ') -- C A 
for value in d.values():
    print(value, end=' ') -- 14 12
for key, value in d.items():
    print(key, value, end=' ') -- C 14; A 12;

#Example of list in dictionary
example = {'A': [22, 33, 44], 'B': [10, 20]}

print(example['A'][1])

#Example 
d = {}
d = {'a': 239,10:100}, a - key, 239 - value
print(d['a']) -- prints 239
print(d[10]) -- prints 100

#Loop example
for key in d:
    print(key, d[key])

#Build keys 
def update_dictionary(d, key, value):
    try:
        for i in d:
            if not isinstance(d[i], list):
                d[i] = [d[i]]
        if key in d:
            d[key].append(value)
        elif 2 * key in d:
            d[2 * key].append(value)
        else:
            d[2 * key] = [value]
    except TypeError:
        pass

#Put to dictionary 
a = [str(i) for i in input().split()]
key = 1
d = {key: a}
for a in d[key]:
    print(a) 

#Optimized functioning 
d = {}
n = int(input())

for _ in range(n):
    x = int(input())
    if x in d:
        print(d[x])
    else:
        d[x] = f(x)
        print(d[x])

                    ФАЙЛЫ/FILES
ИЗ:
* inf = open('текст.txt', 'r') - open file
* s1 = inf.readline() - read 1 line
* inf.close() - close file
* s = inf.readline().strip() -- removes \n and etc from start and end ( rstrip + lstrip ) 
* import os
    os.path.join('.', 'dirname', 'filename.txt') -- Вывод зависит от используемой ОС
* "\\".join(parts)
* import exceptions 			-- import file as a module
  print(exceptions.greet("Students'))	-- call function from module
* s = inf.read.striplines() -- put into a list after removing \n and etc everywhere 
* s = repr(s) -- convert the whole text into a line 

В:
* ouf = open('file.txt', 'w')
* ouf.write('Some text\n')
* ouf.write(str(25))
* ouf.close() 

* Auto-close: 
with open('текст.txt', 'r') as inf, open('text.txt', 'w') as ouf: -- with _ as _ конструкция
  s2 = inf.readline()
print(s2)

* Построчное чтение файла
with open('input.txt') as inf:
    for line in inf:
        line = line.strip()
        print(line)

#Example 
with open('text.txt', 'w') as ouf:
    ouf.write('Some text\n')
    ouf.write(str(25))

#Overwriting example
with open("log.txt", "w") as f:
    f.write("Log started\n")
    f.write("User joined\n")
    f.write("End.\n")

#Format for OS

import os

def build_path(system, *parts):
    if system.lower() == "windows":
        return "\\".join(parts)
    else:
        return "/".join(parts)
        
path_linux = build_path("Linux", "home", "mikhail", "projects", "script.py")
print("Linux-style path:", path_linux)

path_windows = build_path("Windows", "C:", "Users", "Mikhail", "Desktop", "file.txt")
print("Windows-style path:", path_windows)

				ПАПКИ/DIRECTORIES 
import os
* import os.path

* print(os.getcwd()) -- путь к папке
* print(os.listdir(".cache"))
* print(os.path.abspath("main.py")) -- путь и имя папки
* os.chdir(".cache") -- подняться выше по дирректориям, или по нужному пути
* print(os.getcwd())

* print(os.path.exists("files.py"))
* print(os.path.isfile("files.py")) -- проверить существование
* print(os.path.isdir("files.py"))

* for current_dir, dirs, files in os.walk("."): -- returns (directory in stroke, 
    print(current_dir, dirs, files)			   list of subdicts, list of subfiles)

-- . значит текущая дирректория

import os
import os.path
* import shutil

* shutil.copy("tests/test1.txt", "tests/test2.txt")
* shutil.copy("tests", "tests/tests") -- скопировать в другую папку

#Zip unpack, os.walk, endswith. 
import zipfile
import os

with zipfile.ZipFile("main.zip", "r") as zip_ref:
  zip_ref.extractall() -- unpack zip

valid_dirs = set()

for root, dirs, files in os.walk("main"):
  for f in files:
    if f.endswith(".py"):
      valid_dirs.add(root)
      break 

with open("res_file.txt", 'w') as ouf:
  for path in sorted(valid_dirs):
    ouf.write(path + '\n')


#identify digit/alpha

inf = open('текст.txt', 'r')
genom = inf.readline().strip().lower()
inf.close()
n = len(genom)
i = 0

with open('текст.txt', 'w') as inf:
  
  while i < n:
    if genom[i].isalpha():
        letter = genom[i]
        i += 1
        number_str = ""
        while i < n and genom[i].isdigit():
            number_str += genom[i]
            i += 1
  
        if number_str == "":
            print(letter, end='')
            inf.write(letter)
        else:
            print(letter * int(number_str), end='')
            inf.write(letter * int(number_str))
    else:
        i += 1

#Count words(Вариант 1 - неэф.)

with open("dataset_3363_3 3.txt", "r") as f:
  a = f.read().lower().split()

n = len(a)

b = []
c = []
for i in range(n):
  if a[i] in b:
    continue
  elif a[i] not in b:
    k = a.count(a[i])
    b.append(a[i])
    c.append(k)

n = len(c)

if not b or not c:
  print("Файл пуст или не содержит слов.")
else:
  d = 0
  for i in range(n):
    if c[i] > c[d]:
      d = i
    elif c[i] == c[d]:
      if b[i] < b[d]:
        d = i
  print(b[d], c[d], sep=' ')

#Count words(OPTIMIZED)
s, d, m, w = str(), dict(), 0, str()
with open("dataset_3363_3.txt", "r") as f:
    s = f.read().lower().strip().split()
s.sort()
for word in s:
    if word in d:
        d[word] += 1
    else:
        d[word] = 1
for word in d:
    if d[word] > m:
        m = d[word]
        w = word

#sets usage

with open("dataset_3363_4 3.txt", "r") as file:
  mat = pys = rus = 0
  k = []
  l = []
  m = []
  n = []

  for line in file:
      parts = line.strip().split(';')
      name = parts[0]
      scores = parts[1:]
      c = 0
      for i, val in enumerate(scores):
          if val.isdigit():
              valf = float(val)
              c += valf
              if i == 0:
                  mat += valf
                  k.append(valf)
              elif i == 1:
                  pys += valf
                  l.append(valf)
              elif i == 2:
                  rus += valf
                  m.append(valf)
      avg = c / 3
      n.append(avg)

# Print subject averages
print(mat / 3, pys / 3, rus / 3)
print(type(mat/3), type(pys/3), type(rus/3))
print(repr(f"{mat} {pys} {rus}"))

# Write everything in one go
with open("dataset_3363_5.txt", "w") as file:
  for val in n:
    file.write(f"{val}\n")
  file.write(f"{mat/s} {pys/s} {rus/s}")

                            МОДУЛИ
• Модуль - файл с функциями
• Имя файла = имя модуля + .py
* import my_module
    my_module.foo()
* from my_module import foo -- specific function
    foo()
* from my_module import * -- all functions
    foo()
* from my_module import foo as my_foo -- name
    my_foo() 

        ПРИМЕРЫ МОДУЛЕЙ
• sys
    * sys.argv -- list of arguments of command line
- Example:
* import sys
* print(len(sys.argv))

#Example
import sys
print("Full list:", sys.argv)
print(*sys.argv[1:])

• subprocess
    * subprocess.call(args, *,stdin=None,stdout=None,stderr=None,shell=False,timeout=None)
- Example:
import subprocess
subprocess.call(["python", "-h"])
result = subprocess.run(["python", "-h"], capture_output=True, text=True)
print("\nOutput captured using run():")
print(result.stdout)

*Math function
import math
pi = math.pi
r = float(input())
def circle(r):
  return pi * r * 2
print(circle(r))

                        ДОП.БИБЛИОТЕКИ
• requests
1) install requests!

import requests

r = requests.get('http://example.com')
print(r.text)

url = 'http://example.com'
par = {'key1': 'value1', 'key2': 'value2'} 
r = requests.get(url, params=par)
print(r.url)

url = 'http://httpbin.org/cookies'
cookies = {'cookies_are: 'working'}
r = requests.get(url, cookies=cookies)
print(r.text)

print(r.cookies['example_cookie_name'])

------------------------------------------------------

#Матрёшка файлов

import requests

with open('dataset_3378_3.txt', 'r') as file:
    a = file.read().strip()

headers = {'User-Agent': 'Mozilla/5.0'}
r = requests.get(a, headers=headers)

while True:
    if r.text.startswith('We'):
        break
    else:
      next_url = 'https://stepik.org/media/attachments/course67/3.6.3/' + r.text.strip()
      r = requests.get(next_url, headers=headers)

print(r.text)

#Football counting 
n = int(input())
d = {}

for i in range(n):
    a = input().split(';')
    team1, score1, team2, score2 = a[0], int(a[1]), a[2], int(a[3])
    for team in [team1, team2]:
      if team not in d:
          d[team] = [0, 0, 0, 0, 0]
    if score1 < score2:
      d[team2][0] += 1
      d[team2][1] += 1
      d[team2][4] += 3
      d[team1][0] += 1
      d[team1][3] += 1
    elif score1 > score2:
      d[team1][0] += 1
      d[team1][1] += 1
      d[team1][4] += 3
      d[team2][0] += 1
      d[team2][3] += 1
    else:
      d[team1][0] += 1
      d[team2][0] += 1
      d[team1][2] += 1
      d[team2][2] += 1
      d[team1][4] += 1
      d[team2][4] += 1
for key in d:
  print (key, end=':')
  for i in range(len(d[key])):
    print(d[key][i], end=' ')
  print()

#Code/decode using given key
a = input()
b = input()
letters = list(a) -- write by letters
symbols = list(b)

text = list(input())
n = len(text)
g = []
for i in range(n):
  if text[i] in letters:
    g.append(symbols[letters.index(text[i])])

retext = list(input())
n = len(retext)
h = []
for i in range(n):
  if retext[i] in symbols:
    h.append(letters[symbols.index(retext[i])])

for val in g:
  print(val, end='')
print()
for val in h:
  print(val, end='')

#OR

a,b,c,d=input(),input(),input(),input()
print(''.join(b[a.index(i)] for i in c))
print(''.join(a[b.index(i)] for i in d))

#Find unused words
n = int(input())
k = []
l = []
for i in range(n):
  a = input().lower()
  k.append(a)

o = int(input())
for i in range(o):
  b = input().split()
  for j in range(len(b)):
    if b[j].lower() not in k and b[j].lower() not in l:
      l.append(b[j].lower())
for i in range(len(l)):
  print(l[i])

#Root for snake
NS = 0
WE = 0
n = int(input())
for i in range(n):
  a = [x.lower() if not x.isdigit() else int(x) for x in input().split()]
  if a[0] == 'север':
    NS += a[1]
  elif a[0] == 'юг':
    NS -= a[1]
  elif a[0] == 'запад':
    WE -= a[1]
  else:
    WE += a[1] 
print(WE, NS)

#Analize table
heights = {i: [] for i in range(1, 12)}  # классы от 1 до 11 включительно

with open('dataset_3380_5 3.txt', 'r') as file:
    for line in file:
        cls, name, height = line.strip().split()
        cls = int(cls)
        height = int(height)
        heights[cls].append(height)

for cls in range(1, 12):
    if heights[cls]:
        avg = sum(heights[cls]) / len(heights[cls])
        print(f"{cls} {avg}")
    else:
        print(f"{cls} -")

                        RANDOM MODULE
* a = random.randint(0, 17) -- random values in range[a, b] 
* a = random.randrange(0, 101, 10) -- random value in range[a, b)
* a = random.random() -- возвращает число от 0.0 до 1.0 ( не 1.0 )
* a = random.uniform(1.5, 17.3) -- случайное float [1.5, 17.3] 
* random.seed(a=None, version=2) -- будет генерировать одинаково
* from random import * -- теперь не нужно писать random.
* random.shuffle(list) -- перетрести список
* random.choice(list or str) -- выбрать случайный элемент 
* population = ['a', 'b', 'c']
    random.sample(population, 3, counts=[2, 1, 3) -- 3 случайных элемента из 6
* random.triangular(1, 200, 50) -- most likely 50
			COUNTER MODULE
• Counter creates a DICTIONARY, where e.j. a is key and 5 is value
* Counter('abracadabra') -- letters as keys
* Counter(sentence.split()) -- words as keys
* Counter('abracadabra').most_common(n) -- returns n most common letters and their
amounts in a list, e.j. [(a, 5), (b, 2)] 
* You can correspond to c[i] -- bc its a dictionary 
* c.update("banana") -- add new keys
* c.substract("band") -- substract some keys ( negative result possible )
			TIME MODULE 
• Предисловие: tuple - кортёж - упорядоченная коллекция элементов
				как список, но неизменяемая. Заметка: one = (1,)
• Time module gets time, counting from time which depends on a used function(low-level structures)
* time.gmtime(0) -- starts counting from epoch time ( January 1, 1970, 00:00:00(UTC) )
			,returns struct_time(tm_year=2025, tm_mon=4, tm_mday=10, tm_hour=0, 
				tm_min=13, tm_sec=42, tm_wday=3, tm_yday=100, tm_isdst=0)
		#Display Method
		t = time.gmtime()
		print("Year:", t.tm_year)
		print("Minute:", t.tm_min)
		print("Second:", t.tm_sec)
* time.time() -- gives time passed since epoch time(in seconds)
* time.localtime() -- check local time (t.tm_isdst )
* time.sleep() -- freeze cycle, function, program for some time(delay) 
	#Example
	print("Loading", end='')
	for _ in range(3):
	  time.sleep(0.5)
	  print('.', end='')
* time.strftime(format_string, time_struct) -- in (), format string is a string 
						with special codes like %Y, %m, etc,
						if 2nd arg is None - checks localtime. 
#Example of all
now = time.localtime()

formatted = time.strftime(
  "%A, %d %B %Y | %I:%M:%S %p | Weekday: %w | Day of year: %j | Time zone: %Z | DST: %z",now)
	returns: Monday, 08 April 2025 | 02:43:21 PM | Weekday: 1 | Day of year: 098 | 
								Time zone: MSK | DST: +0300
* strptime() -- "parse string" into time
time.strptime(date_string, format_string)
#example: t = time.strptime(s, "%Y-%m-%d %H:%M:%S")
•Most info about time: https://docs.python.org/3/library/time.html
* time.ctime() -- readable time, local if seconds not given. 
ts = 1765400000  # A future timestamp
print(time.ctime(ts)) -- convert time.time() into readable

#Example
import random

for _ in range(10):
    num = random.randint(0, 1)
    if num == 0:
        print('Орел')
    else:
        print('Решка')

#Anti-dumb
def is_valid(a): 
  if a.isdigit() and 1 <= int(a) <= 100 and float(a) % 1 == 0:
    return True
  else:
    return False

#Шар Судьбы
import random

answers = ["Бесспорно", "Мне кажется - да", "Пока неясно, попробуй снова", "Даже не думай",
   "Предрешено", "Вероятнее всего", "Спроси позже", "Мой ответ - нет",
   "Никаких сомнений", "Хорошие перспективы", "Лучше не рассказывать", "По моим данным - нет",
   "Можешь быть уверен в этом", "Да", "Сконцентрируйся и спроси опять", "Весьма сомнительно"]

print('Привет Мир, я магический шар, и я знаю ответ на любой твой вопрос.')
a = input('Введите ваше имя:').split()
print('Привет,', a)
while True:
  b = input('Введите ваш вопрос:')
  print(random.choice(answers))
  c = input('Хотите ли вы задать еще один вопрос? (да/нет):')
  if c.lower() != 'да':
    print('Возвращайся если возникнут вопросы!')
    break
  else:
    continue

#Generate Password
import random
digits = '0123456789'
lowercase_letters = 'abcdefghijklmnopqrstuvwxyz'
uppercase_letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
punctuation = '!#$%&*+-=?@^_'
chars = ''

n = int(input('Количество паролей: '))
l = int(input('Длина одного пароля: '))

k = input('Включать ли цифры 0123456789? (y/n) ')
b = input('Включать ли прописные буквы ABCDEFGHIJKLMNOPQRSTUVWXYZ? (y/n) ')
s = input('Включать ли строчные буквы abcdefghijklmnopqrstuvwxyz? (y/n) ')
v = input('Включать ли символы !#$%&*+-=?@^_? (y/n) ')
w = input('Исключать ли неоднозначные символы il1Lo0O? (y/n) ')

if k.lower() == 'yes':
  chars += digits
if b.lower() == 'yes':
  chars += uppercase_letters
if s.lower() == 'yes':
  chars += lowercase_letters
if v.lower() == 'yes':
  chars += punctuation
if w.lower() == 'yes':
  for c in 'il1Lo0O':
    chars = chars.replace(c, '')

def generate_password(l, chars):
  return random.sample(chars, l)
  
for i in range(n + 1):
  a = generate_password(l, chars)
  for j in range(len(a)): 
    print(a[j], end='')
  print()

РАЗНЫЕ ФУНКЦИИ  

* x = [1, 2, 3]
  print(id(x))
  print(id([1, 2, 3])) -- different ids 
* print(type(id(x))) -- Возвращает тип объекта, ТИП ПОСТОЯНЕН, как и Tuple 
--frozenset -- Неизменяемый set 

#Unique Ids 
ans = 0
unique_ids = []

for obj in objects:
    if not any(obj is other for other in unique_ids):
        unique_ids.append(obj)
        ans += 1
# OR:
objects = [1, 1, 1, 2, 2, 3, 3]
print(len(set(map(id, objects)))) 

print(ans)

* list(map(функция, итерируемый_объект)) -- применить функцию к списку и вернуть как объект 
* lambda x: x**x -- функция без def
# Example:
    students = [('Ivan', 90), ('Masha', 85), ('Sasha', 95)]
    students.sort(key=lambda x: x[1])
    print(students)
# Example:
    lst = [1, 2, 3]
    z = lambda s: sum(s) -- create a function 
    print(z(lst))

* push - кладём на стек ( можно брать как из стакана - только то, что сверху
* pop - забираем некое значение из списка и присваиваем ( anti-append )
Processing tasks from a list
tasks = ['clean', 'write', 'sleep']

while tasks:
    current = tasks.pop() -- substract and use
    print(f'Doing task: {current}')

* print(10, b=20) -- Сначала передаём позиционные значения 
* printab(**args) == printab(key1=args[key1],key2=args[key2])
* def printab(a, b=10) -- Еси ничего, то используем 10, иначе - введённое значение 
* sort() - по возрастанию, sorted(reverse = true) - по убыванию
* def function_name(
    positional_args, positional_args_with_default=default, *args, keyword_only, 
    keyword_only_with_default=default, **kwargs)

• СТЕК ВЫЗОВОВ хранит функции, которые мы вызвали. Функция началась - кладём на стек,
функция закончилась - снимаем со стека.

* fib 
def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n - 1) + fib(n - 2)

math.comb(9,2) <=> n! / (k! * (n - k!))
math.perm(9, 2) -- same but count different orders too 
* namespaces - абстракция для работы с областями видимости 
• Область видимоти определяет, какие переменные и функции доступны в данном контексте (scope) - кусок кода
Области видимости статичны, области действия соответствует её неймспейс.
Пример:
def b(): 
    x = 31
    def a(): 
        print(x) -- a scope in b scope in global scope, but exist in namespace 
    a()
b() 

Пример:
def a():
    print(x)
def b():
    x = 31
    a() -- name error, bc a scope not in b scope
x = 11 -- no error, found in global scope - taken from global namespace

Difference:
def outer():
    a = 'outer'
    
    def inner():
        b = 'inner'
        print(a)
        print(b)
    inner()
Типы:
Local
    Enclosing
        Global
            Builtins 

Namespaces:
	•	a is in the namespace of outer().
	•	b is in the namespace of inner().

Scopes:
	•	Inside inner(), the scope includes:
	•	b (local)
	•	a (enclosing scope from outer())


* builtins > global namespace:
    int, str, float, bool, max, min, abs, id... 
  namespace main - верхний, глобальный namespace. Something in function - local namespace 

Для условных операторов local namespace не создаётся 
for i in range(5):
	x = i -- попадает в global namespace

* global variable -- take and edit something global using local namespace
#Example
ok_status = True
vowels = ["a", "e", "i", "o", "u"]

def check(word):
  global ok_status
  for vowel in vowels:
    if vowel in word:
      return True
  ok_status = False
  return False
print(check("hello"))
print(ok_status)
print(check('www'))
print(ok_status)

* globals() returns a DICTIONARY

That dictionary holds variable names as keys, and their actual values as values.
d = globals()
d['x']  # => 5


* nonlocal variable -- take and edit enclosing variable 
#Example 
def f():
  ok_status = True
  vowels = ['a', 'u', 'i', 'e', 'o']
  
  def check(word):
    nonlocal ok_status
    for vowel in vowels:
	if vowel in word:
        return True
    ok_status = False
    return False
    
  print(check('abacaba'))
  print(ok_status)
  print(check('www'))
  print(ok_status)
f()

#Functions Through Input
n = int(input())

-- parent[child] = parent_namespace
parent = {'global': None}

# vars[namespace] = set of variable names
vars = {'global': set()}

def get(ns, var):
    if var in vars.get(ns, set()):
        return ns
    elif parent[ns] is None:
        return 'None'
    else:
        return get(parent[ns], var)

for _ in range(n):
    cmd = input().split()
    if cmd[0] == 'create':
        namespace, parent_name = cmd[1], cmd[2]
        parent[namespace] = parent_name
        vars[namespace] = set()
    elif cmd[0] == 'add':
        namespace, var = cmd[1], cmd[2]
        vars[namespace].add(var)
    elif cmd[0] == 'get':
        namespace, var = cmd[1], cmd[2]
        print(get(namespace, var))

{«Пространство»: [«Родитель», «Множество зависимых пространств»]}
{«Пространство»: «Множество переменных»}.

* if h and h not in d[val]: -- checks if h is not empty ( is True ) at first 
*  d[val].append(h.copy()) -- without using copy it would change if we would have changed h 

			КЛАССЫ

• Classes let you make YOUR OWN commands, syntax. list, dict, tuple  - class. 
class MyClass:
  #class body -- used only in the moment of defining class
• names defined in classe's namespace get ANCHORED to the name of CLASS 
• After class done - object 'MyClass' is created 
#Example of usage 1:
class MyClass:
  a = 10 -- field, property.        
  def func(self): -- method
    print('Hello')
print(MyClass, a)
print(MyClass.func) -- a и func - атрибуты объекта MyClass 

#Example of usage 2:
class Counter:
   pass
Counter -- class object
x = Counter() -- x is instance object ( экземпяр класса ) - can only use attributes
x.count = 0 -- new attribute
x.count += 1


• У классов всегда можно вызвать конструктор 
* Констрнуктор нужен для того, чтобы создавать объекты класса
* Конструктор есть у КАЖДОГО объекта в python, и это единственный механизм, в котором 
  создаются объекты.
# class Counter:
   def __init__(self): -- 1. create empty attribute 2. give it to self - so init sets attributes
	self.count = 0
Counter
x = Counter()
print(x.count) -- 0
x.count += 1

# class Counter:
   def __init__(self, start=0): -- inicialisation starts AFTER SELF, other do that BY ARGUMENTS
	self.count = start		we gve into constructor. self makes it work for word in 
Counter							THE WHOLE class.
x1 = Counter(10)
x = Counter()
print(x.count)
x.count += 1

#Example
class LibraryBook:
  def __init__(self, title, author):
    self.title = title
    self.author = author
    self.status = 'available'
    
  def borrow(self):
    if self.status == 'available':
      print(f'borrowing {self.title}')
      self.status = 'borrowed'
    else:
      print(f'Already borrowed')
    
  def return_book(self):
    if self.status == 'borrowed':
        print(f"Returned {self.title}")
        self.status = 'available'
  else:
      print(f"{self.title} wasn't borrowed")
    
  def display_status(self):
    print(f'{self.title} by {self.author} is {self.status}')

library = []
for i in range(int(input())):
  title = f"book #{i+1}"
  author = f"Author {chr(65 + (i%26))}"
  book = LibraryBook(title,author)
  library.append(book)

#Example
class Counter:
  def __init__(self):
    self.count = 0
  def inc(self):
    self.count += 1
  def reset(self):
    self.count = 0

x = Counter()
* x.inc() -- Bound Method - find function and link it to an object 
print(x.count)
* Counter.inc(x) -- same as x.inc() 

def add(self, v):
    if self.can_add(v): -- you can call other functions inside of a class 
      self.a += self.v

#Save in lists
class Buffer:
  def __init__(self):
    self.b = []
    self.c = []

  def add(self, *a):
    self.b.extend(a) -- faster than '+' 
    while len(self.b) >= 5:
      chunk = self.b[:5]
      self.c.append(chunk)
      self.b = self.b[5:]

  def get_current_part(self):
    print(self.b)
    return self.b

• НАСЛЕДОВАНИЕ КЛАССОВ - make an object be almost like some class, but with changes 
* class DerivedClassName(Base1, Base2, Base3): -- inheriting from a class, 
						   multiple inheritance
#Example
class MyList(list): -- MyList is НаследуЮЩИЙ class, list is наследуЕМЫЙ class(Parent)
  def even_length(self): -- additional method 
    return len(self) % 2 == 0
x = MyList()
print(x)
x.extend([1, 2, 3, 4, 5])
print(x)
print(x.even_length())
x.append(6)
print(x.even_length())
• Mulptiple inheritance checkig structure.
class D: pass -- inheritance from class 'object' 
class E: pass			>D
class B(D, E): pass	     >B>
class C: pass		   A>	>E
class A(B, C): pass	     >C

* issubclass(A, D) -- True
* isinstance(x, D) -- True ( if used something like x = A() and A is an inheritance of D ) 
* print(B.__mro__) get full tree vein, e.j. (<class '__main__.B'>, <class '__main__.A'>, <class 'object'>)
				MRO <=> Method Resolution Order
• Order of multiple inheritance
class D: pass
class E: pass
class B(D, E): pass
class C: pass
class A(B, C): pass

print(A.mro()) -- gives first resolution order, then second ( each class once )
				работает по принципу слева направо.

#Example + *REDEFINE A FUNCTION
class EvenLengthAddon:
  def even_length(self):
    return len(self) % 2 == 0

class MyList(list, EvenLengthAddon):
  def pop(self): 
    x = super(MyList, self).pop() -- super(find first class where it exists in subclass, object)
    print("Last value is", x)			<=> list.pop(self)
    return x

ml = MyList([1, 2, 4, 17])
z = ml.pop()
print(z)
print(ml)

• Logic Check
class A:
   def foo(self):
      print("A")

class B(A):
   pass

class C(A):
   def foo(self):
      print("C")

class D:
   def foo(self):
      print("D")

class E(B, C, D):
   pass

E().foo()

• What MRO first gets:
[B, A, object]
[C, A, object]
[D, object]
1) B not tailed(first in list), take it. 2)C not tailed - take it(bc A is tailed in 2nd) 
3) A not tailed now - take it. 4) D not tailed - take it.

Python picks the first class (head) from these lists 
that is not present later in any other list.

• ERROR ( rule )
class A: pass
class B(A): pass
class C: pass
class D(C): pass
class E(B, C, D): pass  # ← Error happens here

	it cycles, bc builds this:
	[B, A, object]
	[C, object]
	[D, C, object]
	and [B, C, D] (the direct bases)

#Recursion Example
def find_path(start, path):
    path.add(start)
    for node in graph[start]:
        if node not in path:
            find_path(node, path)

graph = {}
for i in range(int(input())):
    s = input().split()
    graph[s[0]] = s[2:] if len(s) > 1 else [s[0]]

for i in range(int(input())):
    s = input().split()
    path = set()
    find_path(s[1], path)
    print('Yes' if s[0] in path else 'No')

#Extended List Operations Class 
class ExtendedStack(list):
  def sum(self):
    self.append(self.pop() + self.pop()) -- self is out lst!

  def sub(self):
    self.append(self.pop() - self.pop())

  def mul(self):
    self.append(self.pop() * self.pop())

  def div(self):
    self.append(self.pop() // self.pop())

#Another example of remaking functions 
class LoggableList(list, Loggable):
  def append(self, val):
    super(LoggableList, self).append(val)
    self.log(val)

•Try, Except, Finally -- safely do errors 
def f(x, y):
  try:
    return x / y
  except (TypeError, ZeroDivisionError) as e: -- can also be except () 
    print(type(e))
    print(e) -- division by zero 
    print(e.args)

•Parenting in try, except
print(f(5, 0))
print(f(5, []))
try:
  15 / 0
except ZeroDivisionError:
  print("Division by zero")

print(ZeroDivisionError.mro()) -- ZeroDivisionError < ArithmeticError, Exception <
							<BaseException < Object
• FULL	construction
def divide(x, y):
  try:
    result = x/y
  except ZeroDivisionError:
    print("division by zero")
  else: 			-- if not except
    print("result is", result)
  finally:			-- no matter what
    print("finally")

* assert x > 0 -- if False, then stops the code 

except ZeroDivisionError as e:
  print(type(e).__name__)	 -- print NAME OF A CLASS 

* Make error where we want
def greet(name):
  if name[0].isupper():
    return "Hello, " + name
  else:
    raise ValueError(name + " is inapproptiate name") -- create error

while True:
  try
    name = input("Please enter your name")
    greeting = greet(name)
    print(greeting)
  except ValueError:
    print("Please try again")
  else:
    break

* Make new exception classes
class BadName(Exception):
  pass
def greet(name):
  if name[0].isupper():
    return "Hello, " + name
  else:
    raise BadName(name + " is inapproptiate name") -- returns BadName ERROR!

#Recursion example
n = int(input())
parents = {}
lst = []

for _ in range(n):
  a = input().split()
  if a[0] not in parents:
    parents[a[0]] = []
  for j in range(2, len(a)):
    if a[j] not in parents[a[0]]:
      parents[a[0]].append(a[j])

def collect_ancestors(cls, visited=None):
  if visited is None:
    visited = set()
  if cls not in parents or cls in visited:
    return set()
  visited.add(cls)
  result = set(parents[cls])
  for parent in parents[cls]:
    result.update(collect_ancestors(parent, visited))
  return result

m = int(input())
for _ in range(m):
  lst.append(input().strip())

seen = set()
for cls in lst:
  ancestors = collect_ancestors(cls)
  if seen & ancestors:
    print(cls)
  seen.add(cls)

#OP RECURSION
def checkdup(d):
    return cls[d] is None or any(map(checkdup, cls[d])) -- if any of _ is True,
								'any' returns true
cls = {d: set(b[1:]) for _ in range(int(input())) for d, *b in [input().split()]}

for _ in range(int(input())):
    c = input()
    if checkdup(c):
        print(c)
    cls[c] = None

				ИСПОРТИРОВАНИЕ МОДУЛЕЙ
• Ищется в sys.modules ( dict )

• Not to run the ENTIRE thing but to use a wanted part 
def fib(k):
  if k == 0 or k == 1:
    return 1
  else:
    return fib(k - 1) + fib(k - 2)

print(__name__)
if __name__ == "Main": 		--check file's name
  print(fib(31))

• Повторное импортирование НЕВОЗМОЖНО 
• redefine function locally
from exceptions import BadName, greet as exc_greet
import exceptions as exc 

def greet():
  print("Greetings!")
greet()
print(exc_greet("Student")) 

• To import using * add ( to an exporting file ) __all__ = ["BadName", "greet"] - e.j. 
	o

• Module is searched 
import sys 
import numpy
print(sys.modules)
print(type(check))a
• Shows the way it was found ( searches in libraries(in packets - many modules packed))
import sys
for i in sys.path:
  print(i)
• you can donload many libraries from PyPI - Python Package Index (pypi.python.org) 
 * pip install numpy -- to install using shell



* Datetime module example - count date
from datetime import date, timedelta
a = date(*map(int, input().split())) -- unpack a tuple 
b = timedelta(int(input()))
c = a + b
print(c.year, c.month, c.day)


				ИТЕРАТОРЫ, ГЕНЕРАТОРЫ
• iterator - определяет порядок обхода элементов коллекции
  iterable - объект, который может быть передан в функцию iter()
lst = [1, 2, 3, 4, 5, 6]
book = {'title:', 'The Langoliers', 'author:', 'year:', 1990}
string = "Hello, World!"

for i in book:
  print(i)

iterator = iter(book)

while True:
  try:
    i = next(iterator) -- iterate and get next element
    print(i)
  except StopIteration:
    break
• Iteration is for building custom cycles 
from random import random

class RandomIterator:
  def __iter__(self): -- make it iterator
    return self

  def __init__(self, k):
    self.k = k
    self.i = 0

  def __next__(self):    -- x.__next__() <=> x - give possibilities ИТЕРАТОРА
    if self.i < self.k:
      self.i += 1
      return random()
    else:
      raise StopIteration

for x in RandomIterator(10):
  print(x)

•Iteration is NEEDED as a wrapper, bc otherwise list logic would be used as default 
class DoubleElementIterator:
  def __init__(self, lst):
    self.lst = lst
    self.i = 0
  def __next__(self):		--make a cycle body for iteration
    if self.i < len(self.lst):
      self.i += 2
      return self.lst[self.i - 2], self.lst[self.i - 1]
    else:
      raise StopIteration

class MyList(list):
  def __iter__(self):			  --use iteration wrapping
    return DoubleElementListIterator(self)

for pair in MyList([1, 2, 3, 4]):
  print(pair)

• Generator returns from function multiple times. if 'Yield' is seen in a function -
						- its counted as a generator
class RandomIterator:
  def __iter__(self):
    return self

  def __init__(self, k):
    self.k = k
    self.i = 0

  def __next__(self):
    if self.i < self.k:
      self.i += 1 
      return random()
    else:
      raise StopIteration

def random_generator(k):
  for i in range(k):
    yield random()        --when we ask generator for the next element, it RERUNS function body,
gen = random_generator(3)			after yield it RETURNS a value and REMEMBERS
print(type(gen))				current state of a funsction, so we start from
							this point when doing again, 
							afterall 'StopEterationError'. 
#Example of iteration 
class multifilter:
    def judge_half(pos, neg):
        return pos >= neg

    def judge_any(pos, neg):
        return pos >= 1

    def judge_all(pos, neg):
        return neg == 0

    def __init__(self, iterable, *funcs, judge=judge_any):
        self.iterable = iterable
        self.funcs = funcs
        self.judge = judge

    def __iter__(self):
        for item in self.iterable:
            pos = 0
            neg = 0
            for f in self.funcs:
                if f(item):
                    pos += 1
                else:
                    neg += 1
            if self.judge(pos, neg):
                yield item

#Check if a prime number, also do a range inside lambda

def primes():
  x = 2
  while True:
    for i in range(2, int(x ** 0.5) + 1): -- if has divisors later - has divisors before 
      if x % i == 0:
        break
    else:
      yield x  -- give x back to a function
    x += 1

print(list(itertools.takewhile(lambda x : x <= 31, primes()))) --takes from yield while condition. 

• list comprehension:
z = [(x, y) for x in range(3) for y in range(3) if y >= x][1:] -- check x in y in range(3),
								   don't take first pare
• Can be used as generator onject.
z = ((x, y) for x in range(3) for. y in range(3) if y >= x)
print(z)
print(next(z))
print(next(z))

			MAP/LAMBDA FUNCTIONS 
•map - iterator 

n, k = list(map(int, input().split()))
n, k = ([int(i) for i in input().split()])

• filter(f, a) -- return value if function returns true for it 
x = input().split()
xs = (int(i) for i in x)

def even(x):
  return x % 2 == 0

evens = list(filter(even, xs))
print(evens)
• lambda - short function 

#Example
even = lambda x: x % 2 == 0
evens = list(filter(even, xs))
print(evens)

#Key for sort(key) 
x = [(f"Van, Per, Gil"), (f"Jone, Coll, Hesh"), (f"Lesh, Mesh, Dash")]

x.sort(key=lambda name: len(" ".join(name)))
print(x)

• operator, itemgetter, attgetter
import operator as op

print(op.add(4, 5))
print(op.mul(4, 5))
print(op.contains([1, 2, 3], 4))

x = [1, 2, 3]
f1 = op.itemgetter(1)
f2 = op.attrgetter("sort")   # f2(x) == x.sort
print(f1(x))
print(f2([]))

#Example
x = [(f"Van, Per, Gil"), (f"Jone, Coll, Hesh"), (f"Lesh, Mesh, Dash")]

import operator as op
x.sort(key=op.itemgetter(-1))
print(x)

• functools
* from functools import partial

x = int("1101", base=2)
print(x)

int_2 = partial(int, base=2) -- partially use, remake a function with different keys 
x = int_2("1101")
print(x) 

x = [(f"Van, Per, Gil"), (f"Jone, Coll, Hesh"), (f"Lesh, Mesh, Dash")]

import operator as op
from functools import partial

sort_by_last = partial(list.sort, key=op.itemgetter(-1)) -- use sort, but change key 
print(x)
sort_by_last(x)
print(x)

* reduce applies a function repeatedly, 1 by 1. can have initial value.
reduce(lambda x, y: x + y, [1, 2, 3], 10) -- 10 + 1 + 2 + 3

#Usage of Lambda
def mod_checker(x, mod=0):
  return lambda y: y % x == mod
# Example
def recursive_replace(s, a, b, count=0):
  if a not in b and a in s:
    return recursive_replace(s.replace(a, b), a, b, count + 1)
  return count, s

#count in substring in string
s = input()
t = input()
ans = 0
for i in range(len(s)):
    if s[i:].startswith(t): -- startswith can be used with words, too 
        ans += 1

print(ans)

				  РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ 
x = "hello\nworld" -- перенос сроки
y = "hello\"world"
z = "hello\\world"
print(x)

•Чтобы читать все символы такими, какие они есть - нужно использовать r"_"
x = r"hello\n\world"
print(x)
•re module <=> regular expressions.
  * re.match -- ищет совпадение в начале строке, потом возвр. как match
	#Пример возвращения match
	<re.Match object; span=(0, 4), match='abcd'> or None, span - range taken
  * re.search -- найти подходящий диапозон, если есть
    pattern = r"abcd"
    string = "babcd"
    match_object = re.search(pattern, string)
  * re.findall -- все строки, подходящие под шаблон
     pattern = r"a[a-z]c" -- любая буква в диапозоне
     string = "abcaccaacadc"
     all_inclusions = re.findall(pattern, string) -- находит ВСЕ подход. В ЧЁМ УГОДНО. List. 
     print(all_inclusions)
  * re.sub(pattern, "abc", string) -- заменить все подходящие на abc(автозамена) 



• Метасимволы
   | Метасимвол | Значение                        | Пример                     |
|------------|----------------------------------|-----------------------------|
| `.`        | Любой один символ               | `a.b` → `acb`, `a_b`, `a3b` |
| `^`        | Начало строки                   | `^Hello` → только в начале  |
| `$`        | Конец строки                    | `world$` → только в конце   |
| `*`        | 0 или более повторений          | `ab*` → `a`, `ab`, `abb`... |
| `+`        | 1 или более повторений          | `ab+` → `ab`, `abb`, но не `a` |
| `?`        | 0 или 1 повторение              | `ab?` → `a` или `ab`        |
| `[]`       | Набор символов                  | `[abc]` → `a` или `b` или `c` |
| `\d`       | Цифра (0–9)                     | `\d\d` → две цифры подряд   |
| `\w`       | Буква, цифра или _              | `\w+` → слово               |
| `\s`       | Пробел                          | `\s+` → один или несколько пробелов |
| `|`        | Или                             | `cat\|dog` → `cat` или `dog` |
| `()`       | Группа (для логики/захвата)     | `(ab)+` → `ab`, `abab`, ... |

Примеры:
1) []
  pattern = r"a[abc]c"
string = "acc"
match_object = re.match(pattern, string)
2) ^
  pattern = r"[^a-zA-Z]c" -- все, кроме ^...
string = "a.c, a-c, a,c"
3) .
  pattern = r"a.c" -- что угодно, кроме \n
Сокращения:
1) \d - [0-9] -- цифры - r"a\dc" <=> r"a[0-9]c"
2) \D - [^0-9] -- не цифры.  
3) \s - [ \t\n\r\f\v ] -- пробельные символы
4) \S - [ ^\t\n\r\f\v ]
5) \w - [a-zA-Z0-9_] --буквы + цифры + _
6) \W - [^a-zA-Z0-9_]
комбинации: r"a[\w.]c", r"a[\w\s]c" ...

Указать группу: ( действуют жадно - по-умолчанию берут самый динный вариант ) 
1) * -- Любое количество символа от нуля
  pattern = r"ab*a"
string = "aa, aba, abba"
2) + -- Любое количество от 1
  pattern = r"ab+a"
string = "aba, abba"
3) ? -- 0 или 1 вхождение
  pattern = r"ab?a"
string = "aa, aba"
4) {n} -- сколько конкретно интересует 
  pattern = r"ab{2,4}a"
string = "abba, abbba, abbbba"
   Самое короткое выражение:
	pattern = r"a[ab]+?a"
5) () -- группировка цуликом
    Или:
	pattern = r"(test|text)*" -- | значит или
	string = "testtest"
   Или:
	pattern = r"abc|(test|text)"
	string = "abc"
  Или:
	pattern = r"((abc|(test|text)*))"
	string = "abc"
	match = re.match(pattern, string
	print(match.groups()) -- находит группы (abc, abc, None) - внешние, первые 
							 внутренние, вторые внутренние,
							запоминает последнее вхождение 
	pattern = r"Hello (abc|text)"
	string = "Hello abc"
	match = re.match(pattern, string)
	print(match.group(0)) -- группы можно индексировать 
	print(match.group(1))
